<Project>

  <!--
    ProjectOrImageReference: Compile-time switching between project references and container images.

    Usage in AppHost .csproj:
      <ProjectOrImageReference Include="..\MyService\MyService.csproj"
                                ContainerImage="myregistry.azurecr.io/my-service"
                                ContainerTag="latest" />

    Build with projects (default):  dotnet build
    Build with containers:          dotnet build -p:UseContainerImages=true

    When UseContainerImages != true:
      - Items become ProjectReference (Aspire SDK generates IProjectMetadata classes)
      - AppHost code uses: builder.AddProject<Projects.MyService>("myservice")

    When UseContainerImages == true:
      - Items do NOT become ProjectReference
      - A source file is generated with #if USE_CONTAINER_IMAGES blocks
      - AppHost code uses conditional compilation to switch behavior
  -->

  <PropertyGroup Condition="'$(UseContainerImages)' == 'true'">
    <DefineConstants>$(DefineConstants);USE_CONTAINER_IMAGES</DefineConstants>
  </PropertyGroup>

  <!-- When NOT using containers: convert to ProjectReference so Aspire SDK generates IProjectMetadata -->
  <ItemGroup Condition="'$(UseContainerImages)' != 'true'">
    <ProjectReference Include="@(ProjectOrImageReference)" />
  </ItemGroup>

  <!-- When using containers: generate metadata source file -->
  <Target Name="_GenerateContainerImageMetadata"
          BeforeTargets="CoreCompile"
          Condition="'$(UseContainerImages)' == 'true'"
          Inputs="@(ProjectOrImageReference)"
          Outputs="$(IntermediateOutputPath)Aspire\containers\%(ProjectOrImageReference.Filename).ContainerMetadata.g.cs">

    <PropertyGroup>
      <_ContainerMetadataDir>$(IntermediateOutputPath)Aspire\containers\</_ContainerMetadataDir>
    </PropertyGroup>

    <MakeDir Directories="$(_ContainerMetadataDir)" />

    <_GenerateContainerMetadataSource
      Items="@(ProjectOrImageReference)"
      OutputDirectory="$(_ContainerMetadataDir)" />

    <ItemGroup>
      <Compile Include="$(_ContainerMetadataDir)*.ContainerMetadata.g.cs" />
    </ItemGroup>
  </Target>

  <!-- Inline task to generate C# source for container metadata -->
  <UsingTask TaskName="_GenerateContainerMetadataSource"
             TaskFactory="RoslynCodeTaskFactory"
             AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <Items ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <OutputDirectory ParameterType="System.String" Required="true" />
    </ParameterGroup>
    <Task>
      <Code Type="Fragment" Language="cs">
<![CDATA[
foreach (var item in Items)
{
    var filename = System.IO.Path.GetFileNameWithoutExtension(item.ItemSpec);
    var className = filename.Replace(".", "_").Replace("-", "_");
    var image = item.GetMetadata("ContainerImage");
    var tag = item.GetMetadata("ContainerTag");
    var registry = item.GetMetadata("ContainerRegistry");

    if (string.IsNullOrEmpty(tag)) tag = "latest";

    var registryLine = string.IsNullOrEmpty(registry)
        ? "    public static string? Registry => null;"
        : $"    public static string Registry => \"{registry}\";";

    var source = $@"// <auto-generated />
#nullable enable
namespace Containers;

public static class {className}
{{
    public static string Image => ""{image}"";
    public static string Tag => ""{tag}"";
{registryLine}
}}
";

    var outputPath = System.IO.Path.Combine(OutputDirectory, $"{filename}.ContainerMetadata.g.cs");
    System.IO.File.WriteAllText(outputPath, source);
}
]]>
      </Code>
    </Task>
  </UsingTask>

</Project>
