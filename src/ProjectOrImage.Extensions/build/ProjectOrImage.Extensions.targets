<Project>

  <!--
    ProjectOrImageReference: Per-resource compile-time switching between project references and container images.

    Usage in AppHost .csproj:
      <PropertyGroup>
        <ContainerResources></ContainerResources>
      </PropertyGroup>

      <ProjectOrImageReference Include="ApiService"
          RepoDirectory="api-service"
          ProjectFile="src/ApiService/ApiService.csproj"
          ContainerImage="myregistry.azurecr.io/api-service"
          PublishCommand="./build.sh publish" />

    Build with all projects (default):  dotnet build
    Build with some as containers:      dotnet build -p:ContainerResources=ApiService
    Build with multiple as containers:  dotnet build -p:ContainerResources=ApiService,OtherService
  -->

  <PropertyGroup>
    <_ReposBasePath>$(REPOS_BASE_PATH)</_ReposBasePath>
    <!-- Pad ContainerResources with commas for reliable substring matching -->
    <_ContainerResourcesPadded>,$(ContainerResources),</_ContainerResourcesPadded>
  </PropertyGroup>

  <!--
    Evaluation-time: Add ALL ProjectOrImageReference items as ProjectReference.
    Container-mode items will be removed in a target before Aspire generates metadata.
  -->
  <ItemGroup>
    <ProjectReference Include="@(ProjectOrImageReference -> '$(_ReposBasePath)/%(RepoDirectory)/%(ProjectFile)')" />
  </ItemGroup>

  <!--
    Remove container-mode ProjectReferences before Aspire generates IProjectMetadata classes.
    Must run before _CreateAspireProjectResources which reads ProjectReference items.
  -->
  <Target Name="_RemoveContainerModeProjectReferences"
          BeforeTargets="_CreateAspireProjectResources"
          Condition="'$(ContainerResources)' != ''">

    <_ClassifyProjectOrImageReference
      Items="@(ProjectOrImageReference)"
      ContainerResources="$(ContainerResources)"
      ReposBasePath="$(_ReposBasePath)">
      <Output TaskParameter="ContainerItems" ItemName="_ContainerModeToRemove" />
    </_ClassifyProjectOrImageReference>

    <ItemGroup>
      <ProjectReference Remove="@(_ContainerModeToRemove -> '$(_ReposBasePath)/%(RepoDirectory)/%(ProjectFile)')" />
    </ItemGroup>
  </Target>

  <!-- Build container images and generate code -->
  <Target Name="_GenerateProjectOrImageCode"
          BeforeTargets="CoreCompile"
          Condition="'@(ProjectOrImageReference)' != ''">

    <PropertyGroup>
      <_ContainerMetadataDir>$(IntermediateOutputPath)Aspire/containers/</_ContainerMetadataDir>
    </PropertyGroup>

    <MakeDir Directories="$(_ContainerMetadataDir)" />

    <_ClassifyProjectOrImageReference
      Items="@(ProjectOrImageReference)"
      ContainerResources="$(ContainerResources)"
      ReposBasePath="$(_ReposBasePath)">
      <Output TaskParameter="ContainerItems" ItemName="_ContainerModeReference" />
    </_ClassifyProjectOrImageReference>

    <!-- Build container images for container-mode resources -->
    <_BuildContainerImages
      Items="@(_ContainerModeReference)"
      ReposBasePath="$(_ReposBasePath)"
      Condition="'@(_ContainerModeReference)' != ''" />

    <!-- Generate ResourceFlags, ContainerImages, and stub Projects classes -->
    <_GenerateProjectOrImageSource
      AllItems="@(ProjectOrImageReference)"
      ContainerItems="@(_ContainerModeReference)"
      ContainerResources="$(ContainerResources)"
      ReposBasePath="$(_ReposBasePath)"
      OutputDirectory="$(_ContainerMetadataDir)" />

    <ItemGroup>
      <Compile Include="$(_ContainerMetadataDir)ResourceFlags.g.cs" Condition="Exists('$(_ContainerMetadataDir)ResourceFlags.g.cs')" />
      <Compile Include="$(_ContainerMetadataDir)ContainerImages.g.cs" Condition="Exists('$(_ContainerMetadataDir)ContainerImages.g.cs')" />
      <Compile Include="$(_ContainerMetadataDir)ProjectStubs.g.cs" Condition="Exists('$(_ContainerMetadataDir)ProjectStubs.g.cs')" />
    </ItemGroup>
  </Target>

  <!-- Task: Classify items into project-mode vs container-mode -->
  <UsingTask TaskName="_ClassifyProjectOrImageReference"
             TaskFactory="RoslynCodeTaskFactory"
             AssemblyFile="$(MSBuildToolsPath)/Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <Items ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <ContainerResources ParameterType="System.String" />
      <ReposBasePath ParameterType="System.String" />
      <ContainerItems ParameterType="Microsoft.Build.Framework.ITaskItem[]" Output="true" />
    </ParameterGroup>
    <Task>
      <Code Type="Fragment" Language="cs">
<![CDATA[
var containerSet = new System.Collections.Generic.HashSet<string>(System.StringComparer.OrdinalIgnoreCase);
if (!string.IsNullOrEmpty(ContainerResources))
{
    foreach (var name in ContainerResources.Split(new[] { ',' }, System.StringSplitOptions.RemoveEmptyEntries))
    {
        containerSet.Add(name.Trim());
    }
}

var containerList = new System.Collections.Generic.List<Microsoft.Build.Framework.ITaskItem>();

foreach (var item in Items)
{
    if (containerSet.Contains(item.ItemSpec))
    {
        containerList.Add(item);
    }
}

ContainerItems = containerList.ToArray();
]]>
      </Code>
    </Task>
  </UsingTask>

  <!-- Task: Build container images (check SHA, run publish command) -->
  <UsingTask TaskName="_BuildContainerImages"
             TaskFactory="RoslynCodeTaskFactory"
             AssemblyFile="$(MSBuildToolsPath)/Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <Items ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <ReposBasePath ParameterType="System.String" />
    </ParameterGroup>
    <Task>
      <Code Type="Fragment" Language="cs">
<![CDATA[
foreach (var item in Items)
{
    var resourceName = item.ItemSpec;
    var repoDir = item.GetMetadata("RepoDirectory");
    var containerImage = item.GetMetadata("ContainerImage");
    var publishCommand = item.GetMetadata("PublishCommand");

    if (string.IsNullOrEmpty(containerImage))
    {
        Log.LogWarning($"ProjectOrImageReference '{resourceName}' is in container mode but has no ContainerImage metadata.");
        continue;
    }

    var basePath = string.IsNullOrEmpty(ReposBasePath) ? "" : ReposBasePath;
    var repoPath = System.IO.Path.Combine(basePath, repoDir ?? "");

    if (!System.IO.Directory.Exists(repoPath))
    {
        Log.LogWarning($"Repository directory '{repoPath}' does not exist for resource '{resourceName}'. Skipping image build.");
        continue;
    }

    // Get git HEAD SHA
    var sha = "";
    try
    {
        var gitProcess = new System.Diagnostics.Process();
        gitProcess.StartInfo.FileName = "git";
        gitProcess.StartInfo.Arguments = "rev-parse --short HEAD";
        gitProcess.StartInfo.WorkingDirectory = repoPath;
        gitProcess.StartInfo.RedirectStandardOutput = true;
        gitProcess.StartInfo.UseShellExecute = false;
        gitProcess.Start();
        sha = gitProcess.StandardOutput.ReadToEnd().Trim();
        gitProcess.WaitForExit();
    }
    catch (System.Exception ex)
    {
        Log.LogWarning($"Failed to get git SHA for '{resourceName}': {ex.Message}");
        continue;
    }

    if (string.IsNullOrEmpty(sha))
    {
        Log.LogWarning($"Could not determine git SHA for '{resourceName}' at '{repoPath}'.");
        continue;
    }

    var imageTag = $"sha-{sha}";
    var fullImage = $"{containerImage}:{imageTag}";

    item.SetMetadata("ResolvedTag", imageTag);

    // Check if image already exists locally
    var imageExists = false;
    try
    {
        var inspectProcess = new System.Diagnostics.Process();
        inspectProcess.StartInfo.FileName = "docker";
        inspectProcess.StartInfo.Arguments = $"image inspect {fullImage}";
        inspectProcess.StartInfo.RedirectStandardOutput = true;
        inspectProcess.StartInfo.RedirectStandardError = true;
        inspectProcess.StartInfo.UseShellExecute = false;
        inspectProcess.Start();
        inspectProcess.StandardOutput.ReadToEnd();
        inspectProcess.StandardError.ReadToEnd();
        inspectProcess.WaitForExit();
        imageExists = inspectProcess.ExitCode == 0;
    }
    catch
    {
        // docker not available, assume image doesn't exist
    }

    if (imageExists)
    {
        Log.LogMessage(Microsoft.Build.Framework.MessageImportance.High,
            $"Image '{fullImage}' already exists locally. Skipping build for '{resourceName}'.");
        continue;
    }

    if (string.IsNullOrEmpty(publishCommand))
    {
        Log.LogWarning($"No PublishCommand specified for '{resourceName}'. Cannot build image.");
        continue;
    }

    Log.LogMessage(Microsoft.Build.Framework.MessageImportance.High,
        $"Building image for '{resourceName}': running '{publishCommand}' in '{repoPath}'...");

    try
    {
        var buildProcess = new System.Diagnostics.Process();
        buildProcess.StartInfo.FileName = "/bin/bash";
        buildProcess.StartInfo.Arguments = $"-c \"{publishCommand}\"";
        buildProcess.StartInfo.WorkingDirectory = repoPath;
        buildProcess.StartInfo.RedirectStandardOutput = true;
        buildProcess.StartInfo.RedirectStandardError = true;
        buildProcess.StartInfo.UseShellExecute = false;
        buildProcess.Start();

        var stdout = buildProcess.StandardOutput.ReadToEnd();
        var stderr = buildProcess.StandardError.ReadToEnd();
        buildProcess.WaitForExit();

        if (buildProcess.ExitCode != 0)
        {
            Log.LogWarning($"PublishCommand for '{resourceName}' failed (exit code {buildProcess.ExitCode}): {stderr.Trim()}");
            continue;
        }

        var tagProcess = new System.Diagnostics.Process();
        tagProcess.StartInfo.FileName = "docker";
        tagProcess.StartInfo.Arguments = $"tag {containerImage}:latest {fullImage}";
        tagProcess.StartInfo.RedirectStandardOutput = true;
        tagProcess.StartInfo.RedirectStandardError = true;
        tagProcess.StartInfo.UseShellExecute = false;
        tagProcess.Start();
        tagProcess.StandardOutput.ReadToEnd();
        tagProcess.StandardError.ReadToEnd();
        tagProcess.WaitForExit();

        Log.LogMessage(Microsoft.Build.Framework.MessageImportance.High,
            $"Successfully built and tagged image '{fullImage}' for '{resourceName}'.");
    }
    catch (System.Exception ex)
    {
        Log.LogWarning($"Failed to run PublishCommand for '{resourceName}': {ex.Message}");
    }
}
]]>
      </Code>
    </Task>
  </UsingTask>

  <!-- Task: Generate ResourceFlags.g.cs, ContainerImages.g.cs, and ProjectStubs.g.cs -->
  <UsingTask TaskName="_GenerateProjectOrImageSource"
             TaskFactory="RoslynCodeTaskFactory"
             AssemblyFile="$(MSBuildToolsPath)/Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <AllItems ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <ContainerItems ParameterType="Microsoft.Build.Framework.ITaskItem[]" />
      <ContainerResources ParameterType="System.String" />
      <ReposBasePath ParameterType="System.String" />
      <OutputDirectory ParameterType="System.String" Required="true" />
    </ParameterGroup>
    <Task>
      <Code Type="Fragment" Language="cs">
<![CDATA[
var containerSet = new System.Collections.Generic.HashSet<string>(System.StringComparer.OrdinalIgnoreCase);
if (!string.IsNullOrEmpty(ContainerResources))
{
    foreach (var name in ContainerResources.Split(new[] { ',' }, System.StringSplitOptions.RemoveEmptyEntries))
    {
        containerSet.Add(name.Trim());
    }
}

var containerItemMap = new System.Collections.Generic.Dictionary<string, Microsoft.Build.Framework.ITaskItem>(System.StringComparer.OrdinalIgnoreCase);
if (ContainerItems != null)
{
    foreach (var ci in ContainerItems)
    {
        containerItemMap[ci.ItemSpec] = ci;
    }
}

// Helper: derive Aspire-style class name from ProjectFile filename
// e.g. "ProjectOrImage.ApiService.csproj" â†’ "ProjectOrImage_ApiService"
System.Func<string, string> deriveClassName = (projectFile) =>
{
    var filename = System.IO.Path.GetFileNameWithoutExtension(projectFile ?? "");
    return filename.Replace(".", "_").Replace("-", "_");
};

// --- ResourceFlags.g.cs ---
var flagsSb = new System.Text.StringBuilder();
flagsSb.AppendLine("// <auto-generated />");
flagsSb.AppendLine("#nullable enable");
flagsSb.AppendLine("namespace ProjectOrImage;");
flagsSb.AppendLine();
flagsSb.AppendLine("public static class ResourceFlags");
flagsSb.AppendLine("{");
flagsSb.AppendLine("    public static bool IsContainer(string name) => name switch");
flagsSb.AppendLine("    {");
foreach (var item in AllItems)
{
    var name = item.ItemSpec;
    var isContainer = containerSet.Contains(name);
    flagsSb.AppendLine($"        \"{name}\" => {(isContainer ? "true" : "false")},");
}
flagsSb.AppendLine("        _ => false,");
flagsSb.AppendLine("    };");
flagsSb.AppendLine("}");

System.IO.File.WriteAllText(System.IO.Path.Combine(OutputDirectory, "ResourceFlags.g.cs"), flagsSb.ToString());

// --- ContainerImages.g.cs (always generate entries for ALL resources so code compiles in both modes) ---
var imagesSb = new System.Text.StringBuilder();
imagesSb.AppendLine("// <auto-generated />");
imagesSb.AppendLine("#nullable enable");
imagesSb.AppendLine("namespace ProjectOrImage;");
imagesSb.AppendLine();
imagesSb.AppendLine("public static class ContainerImages");
imagesSb.AppendLine("{");
foreach (var item in AllItems)
{
    var name = item.ItemSpec;
    var image = item.GetMetadata("ContainerImage") ?? "";
    var tag = "latest";

    if (containerSet.Contains(name) && containerItemMap.TryGetValue(name, out var ci))
    {
        var resolved = ci.GetMetadata("ResolvedTag");
        if (!string.IsNullOrEmpty(resolved)) tag = resolved;
    }

    imagesSb.AppendLine($"    public static class {name}");
    imagesSb.AppendLine("    {");
    imagesSb.AppendLine($"        public const string Image = \"{image}\";");
    imagesSb.AppendLine($"        public const string Tag = \"{tag}\";");
    imagesSb.AppendLine("    }");
    imagesSb.AppendLine();
}
imagesSb.AppendLine("}");

System.IO.File.WriteAllText(System.IO.Path.Combine(OutputDirectory, "ContainerImages.g.cs"), imagesSb.ToString());

// --- ProjectStubs.g.cs (only for container-mode resources) ---
var stubsSb = new System.Text.StringBuilder();
stubsSb.AppendLine("// <auto-generated />");
stubsSb.AppendLine("#nullable enable");
stubsSb.AppendLine("namespace Projects;");
stubsSb.AppendLine();

var hasStubs = false;
foreach (var item in AllItems)
{
    var name = item.ItemSpec;
    if (!containerSet.Contains(name)) continue;
    hasStubs = true;

    var projectFile = item.GetMetadata("ProjectFile");
    var className = deriveClassName(projectFile);

    stubsSb.AppendLine($"public class {className} : global::Aspire.Hosting.IProjectMetadata");
    stubsSb.AppendLine("{");
    stubsSb.AppendLine("    public string ProjectPath => \"\";");
    stubsSb.AppendLine("    public bool SuppressBuild => true;");
    stubsSb.AppendLine("}");
    stubsSb.AppendLine();
}

if (hasStubs)
{
    System.IO.File.WriteAllText(System.IO.Path.Combine(OutputDirectory, "ProjectStubs.g.cs"), stubsSb.ToString());
}
else
{
    var stubPath = System.IO.Path.Combine(OutputDirectory, "ProjectStubs.g.cs");
    if (System.IO.File.Exists(stubPath)) System.IO.File.Delete(stubPath);
}
]]>
      </Code>
    </Task>
  </UsingTask>

</Project>
