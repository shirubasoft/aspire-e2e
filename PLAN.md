# ProjectOrImageReference - Implementation Plan

## Concept

A compile-time mechanism similar to Aspire's internal `AspireProjectOrPackageReference` that conditionally references either a .NET project (for local development) or a pre-built Docker image (for CI/deployment), controlled by an MSBuild property.

## How Aspire's `AspireProjectOrPackageReference` Works (reference)

- **MSBuild item** in `Aspire.RepoTesting.targets` (repo-internal, not public SDK)
- Controlled by `$(TestsRunningOutsideOfRepo)` property
- When `false`: resolves to `<ProjectReference>` pointing to source `.csproj`
- When `true`: resolves to `<PackageReference>` by identity
- In AppHost projects: `IsAspireProjectResource="false"` prevents library refs from becoming orchestrated resources

## How AppHost Project References Work (public SDK)

1. `Sdk.in.targets` marks `<ProjectReference>` items with `IsAspireProjectResource=true`
2. `Aspire.Hosting.AppHost.in.targets` generates `IProjectMetadata` classes in `Projects` namespace
3. User calls `builder.AddProject<Projects.MyProject>("name")`
4. Runtime creates `ProjectResource`, DCP launches the process

## How Container Resources Work

1. `builder.AddContainer("name", "image", "tag")` creates a `ContainerResource`
2. Image info stored in `ContainerImageAnnotation`
3. DCP pulls and runs the container

## Design: Compile-Time `ProjectOrImageReference`

### Mechanism

An MSBuild `.targets` file that:

1. **Defines a new item type**: `<ProjectOrImageReference>` with metadata for `ContainerImage`, `ContainerTag`, `ContainerRegistry`
2. **Defines a compile constant**: When `$(UseContainerImages) == true`, adds `USE_CONTAINER_IMAGES` to `DefineConstants`
3. **Project mode** (default, `UseContainerImages != true`):
   - Converts `ProjectOrImageReference` items into `ProjectReference` items
   - Aspire SDK generates `IProjectMetadata` classes in `Projects` namespace as usual
   - AppHost code uses `builder.AddProject<Projects.MyService>("name")`
4. **Container mode** (`UseContainerImages == true`):
   - Does NOT create `ProjectReference` items
   - Generates static metadata classes in `Containers` namespace via an inline MSBuild task
   - Each class exposes `Image`, `Tag`, and `Registry` properties
   - AppHost code uses `builder.AddContainerImage("name", Containers.MyService.Image, ...)`

### Compile-Time Switching

AppHost code uses `#if USE_CONTAINER_IMAGES` preprocessor directives:

```csharp
#if USE_CONTAINER_IMAGES
var api = builder.AddContainerImage("api",
    Containers.MyService.Image,
    Containers.MyService.Tag,
    Containers.MyService.Registry)
    .WithHttpEndpoint(targetPort: 8080);
#else
var api = builder.AddProject<Projects.MyService>("api");
#endif
```

### Build Commands

```bash
# Local development (project references)
dotnet build
dotnet run --project src/MyAppHost

# CI/Deployment (container images)
dotnet build -p:UseContainerImages=true
dotnet run --project src/MyAppHost -p:UseContainerImages=true
```

### AppHost .csproj Usage

```xml
<ItemGroup>
  <ProjectOrImageReference Include="..\MyService\MyService.csproj"
                           ContainerImage="myregistry.azurecr.io/my-service"
                           ContainerTag="latest" />
</ItemGroup>

<Import Project="..\Extensions\build\ProjectOrImage.Extensions.targets" />
```

## File Structure

```
project-or-container-reference/
    PLAN.md
    src/
        ProjectOrImage.AppHost/               # Aspire AppHost with #if switching
        ProjectOrImage.ApiService/            # Sample API project
        ProjectOrImage.Web/                   # Sample web frontend
        ProjectOrImage.ServiceDefaults/       # Shared service defaults
        ProjectOrImage.Extensions/            # The extension library
            Features/
                ProjectOrImage/
                    ProjectOrImageExtensions.cs   # AddContainerImage helper
                    ContainerImageReference.cs    # ImageReference record
            build/
                ProjectOrImage.Extensions.targets # MSBuild targets for compile-time switching
        ProjectOrImage.slnx
        Directory.Build.props
        Directory.Packages.props
        .editorconfig
        global.json
```

## Key Design Decisions

1. **Compile-time over runtime**: Uses `#if` directives and MSBuild properties instead of runtime configuration. The decision of project vs container is made at build time.
2. **Code generation**: Container metadata classes are generated by an MSBuild inline task, mirroring how Aspire generates `IProjectMetadata` classes.
3. **Import ordering**: The `.targets` file must be imported AFTER `ProjectOrImageReference` items are defined in the csproj to ensure MSBuild evaluation order is correct.
4. **Type differences**: In container mode, resources are `IResourceBuilder<ContainerResource>` which doesn't implement `IResourceWithConnectionString`. Endpoint-based references (`WithReference(apiService.GetEndpoint("http"))`) are used instead.
